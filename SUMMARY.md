# Tactical RMM Code Signing Tokens - Exploration Summary

## Executive Summary

This exploration analyzed the Tactical RMM codebase to understand code signing tokens, their implementation, agent installation processes, and token management mechanisms. The current repository is a fresh feature branch intended for implementing code signing token functionality.

**Repository Status**: `/home/user/tactical-rmm` (Feature branch: `claude/tactical-rmm-signing-token-01M6rUrmv2r4KUtH7AdBdUuL`)

---

## Key Findings

### 1. What Are Code Signing Tokens?

Code signing tokens are authentication credentials that allow a self-hosted Tactical RMM instance to request digitally signed agent binaries from Amidaware's centralized code signing servers.

**Core Purpose**:
- Reduce antivirus false positives by providing signed executables
- Enable security software whitelisting
- Provide proof of agent authenticity
- Support enterprise compliance requirements

**Key Characteristics**:
- One token per Tactical RMM instance
- Multi-platform support (Windows, Linux, macOS)
- Sponsorship requirement (minimum Tier 1)
- Transparent operation (automatic use during agent generation/updates)

---

### 2. Token Generation and Obtaining

#### Obtaining Process
1. Become a sponsor on GitHub Sponsors, Stripe, or PayPal (minimum Tier 1 tier)
2. Email support@amidaware.com with Discord and GitHub usernames
3. Provide API subdomain (e.g., api.yourdomain.com)
4. Wait 24 hours for token generation and delivery

#### Token Generation Location
- **Generated by**: Amidaware's code signing server infrastructure
- **Trigger**: After sponsor payment verification and confirmation
- **Delivery**: Via email to the sponsor

#### Storage in Tactical RMM
- **Location**: Django backend configuration and database
- **Access**: Only authenticated backend administrators
- **Recommended Security**: Environment variables or secrets vault
- **Never**: Commit tokens to version control

---

### 3. How Tokens Work

#### Token Validation Flow

```
User/Admin generates agent
        ↓
Tactical RMM backend sends request to Amidaware
        ↓
Includes code signing token in request header
        ↓
Amidaware validates token
        ↓
├─ Valid → Returns code-signed binary
└─ Invalid → Returns unsigned binary
        ↓
Agent delivered to user via deployment link or direct download
```

#### Key Components
- **Request**: HTTP POST to Amidaware signing server with token in Authorization header
- **Validation**: Amidaware checks token against active sponsorships
- **Response**: Signed or unsigned agent binary (graceful fallback)
- **Transparency**: Process is automatic, users don't need to manage tokens

---

### 4. Agent Installation Processes

#### Windows Agent Installation

**Method 1: Dynamic EXE via Deployment Link**
- Download from UI: Agents → Install Agent
- Select: Client, Site, Type, Architecture
- System generates deployment link with embedded signing logic
- Share link with target machine
- Execute installer - agent auto-registers

**Method 2: Manual Installation (Signed Inno Setup)**
- Download permanent signed executable: `tacticalagent-vX.X.X-windows-[arch].exe`
- Run with authentication parameters: `--auth`, `--api`, `--client-id`, `--site-id`
- Agent contacts server and completes registration

**Code Location**: `tacticalrmm/api/tacticalrmm/clients/views.py`
- Class: `GenerateAgent(APIView)` (Lines 349-380)
- Method: `generate_winagent_exe()`

#### Linux Agent Installation

**Official Method (Requires Code Signing Token)**
```bash
# Downloaded from Tactical RMM UI as shell script
chmod +x rmm-<CLIENT>-<SITE>-<TYPE>.sh
./rmm-<CLIENT>-<SITE>-<TYPE>.sh

# Script automatically:
# 1. Downloads Go-based agent binary
# 2. Downloads Mesh agent for remote access
# 3. Configures systemd service
# 4. Registers with Tactical RMM
```

**Community Alternative (No Token Required)**
```bash
wget https://raw.githubusercontent.com/netvolt/LinuxRMM-Script/main/rmmagent-linux.sh
chmod +x rmmagent-linux.sh
./rmmagent-linux.sh install 'MeshAgent' 'https://api.yourdomain.com' \
  'CLIENT_ID' 'SITE_ID' 'AUTH_TOKEN' 'server'
```

**Code Location**: `api/tacticalrmm/core/agent_linux.sh` (official Tactical RMM repo)

#### macOS Agent Installation
- Similar to Linux, requires code signing token for official deployment links
- Agents signed with Amidaware certificate

---

### 5. API Endpoints for Code Signing and Agent Management

#### Agent Generation
```
Endpoint: POST /api/agents/generate
Class: GenerateAgent(APIView)
Location: tacticalrmm/clients/views.py
Permissions: AllowAny (public endpoint)

Parameters:
- client_id (required)
- site_id (required)
- agent_type (required): 'server' or 'workstation'
- arch (optional): '64' or '32'
- os_type (optional): 'windows', 'linux', or 'macos'
- token_expiry (optional): days until deployment token expires

Response:
- Signed agent binary (if token valid)
- Unsigned agent binary (if no token or token invalid)
```

#### Deployment Link Management
```
Endpoint: POST /api/deployments/create
Purpose: Create deployment tokens for bulk agent distribution
Features:
- Generates unique deployment tokens
- Associates with specific client/site/os/architecture
- Sets expiry date
- Returns shareable deployment link
```

#### Token Status
```
Endpoint: GET /api/agents/token-status (Admin only)
Response:
{
  "configured": true/false,
  "valid": true/false,
  "signing_enabled": true/false
}
```

#### Agent Installation Scripts
```
Windows: GET /api/agents/install/windows?client_id=X&site_id=Y
Linux:   GET /api/agents/install/linux?client_id=X&site_id=Y
macOS:   GET /api/agents/install/macos?client_id=X&site_id=Y

Response: Customized installation script with embedded credentials
```

---

### 6. Token Generation and Retrieval Mechanisms

#### Server-Side Token Retrieval

```python
# Pseudocode for token usage
def generate_agent(agent_binary):
    # 1. Retrieve token from configuration/database
    token = settings.CODE_SIGNING_TOKEN
    
    # 2. Prepare request to signing server
    headers = {
        'Authorization': f'Bearer {token}',
        'Content-Type': 'application/octet-stream'
    }
    
    # 3. Send to Amidaware signing server
    response = requests.post(
        'https://codesigning.amidaware.com/api/v1/sign',
        headers=headers,
        data=agent_binary,
        timeout=30
    )
    
    # 4. Return signed or unsigned agent
    return response.content if response.status_code == 200 else agent_binary
```

#### Deployment Link Tokens

**Structure**:
- Purpose: One-time or limited installation token per client/site
- Validity: Expires after specified duration
- Reusability: Can be reused until expiration
- Format: URL-safe random token (128 characters)
- Scope: Linked to specific client, site, OS, and architecture

**Example**:
```
https://api.yourdomain.com/deploy/5f7a9c3e2b1d4a6e8f0c2b4d6a8e0f2c
```

**Validation Flow**:
1. User accesses deployment link
2. Server looks up token in database
3. Verifies: not expired, client/site correct
4. Loads code signing auth token
5. Requests signed agent from Amidaware
6. Provides signed agent to installer

---

### 7. Security Implementation

#### Token Protection
- Stored in secure configuration (environment variables or secrets vault)
- Never logged or displayed in logs
- HTTPS-only transmission
- Access limited to authenticated backend administrators
- Should be rotated if compromise suspected

#### Agent Security Context
- **Windows**: Runs under SYSTEM security context
- **Linux**: Runs as root or dedicated tactical user
- **macOS**: Runs with appropriate user permissions

#### Code Signing Benefits (May 2024 Changes)
- Amidaware now uses own Code Signing Root CA (not DigiCert)
- Reason: Hardware token/HSM requirements from DigiCert
- Dynamically generated installers signed with Amidaware cert
- Inno Setup installers still signed with DigiCert OV certificate

---

### 8. Error Handling

#### Common Errors

**"Missing Code Signing Token"**
- Cause: Token not configured or invalid
- Solution: Verify token in settings, contact support@amidaware.com if validation fails

**"Token No Longer Valid"**
- Cause: Token invalidated by Amidaware (compromise, revocation, cancelled sponsorship)
- Solution: Verify sponsorship status, request new token from support

**Unsigned Agent Downloaded**
- Cause: Token not configured or signing failed
- Result: Higher AV false positives, difficult to whitelist
- Fallback: Agent functions normally, but less secure

---

### 9. Documentation Generated

Three comprehensive documentation files have been created:

#### 1. CODE_SIGNING_TOKENS_ANALYSIS.md (16KB, 527 lines)
Complete technical analysis covering:
- Token generation and storage
- Agent installation procedures (Windows, Linux, macOS)
- API endpoints and parameters
- Token retrieval and validation mechanisms
- Security considerations and industry changes
- Troubleshooting and error handling

#### 2. QUICK_REFERENCE.md (2.8KB, 90 lines)
Quick reference guide with:
- Essential information at a glance
- Linux installation commands (official and community)
- Key file locations in codebase
- API endpoint table
- Common issues and solutions
- Security best practices
- Important links

#### 3. IMPLEMENTATION_GUIDE.md (17KB, 476 lines)
Complete implementation guide including:
- Architecture diagrams
- Configuration management
- Django models and services
- API view implementations
- URL routing
- Database models for audit logging
- Testing strategies
- Environment configuration
- Deployment considerations

---

### 10. Next Steps for Feature Branch

This feature branch (`claude/tactical-rmm-signing-token-01M6rUrmv2r4KUtH7AdBdUuL`) should include:

1. **Token Management Service**
   - CodeSigningService class for communicating with Amidaware
   - Token validation and caching
   - Error handling and fallback mechanisms

2. **API Endpoints**
   - Token configuration endpoints (GET/POST/DELETE)
   - Token status endpoint
   - Enhanced agent generation with signing

3. **Database Models**
   - CodeSigningToken model for audit logging
   - DeploymentLink model for tracking links
   - DeploymentLinkLog for usage tracking

4. **UI Components**
   - Admin panel for token management
   - Token status display
   - Error messaging for unsigned agents

5. **Testing**
   - Unit tests for CodeSigningService
   - Integration tests for agent generation
   - Security tests for token protection

6. **Documentation**
   - API documentation
   - Configuration examples
   - Troubleshooting guide

---

## Key Resources

### Official Documentation
- **Code Signing Guide**: https://docs.tacticalrmm.com/code_signing/
- **Agent Installation**: https://docs.tacticalrmm.com/install_agent/
- **How It All Works**: https://docs.tacticalrmm.com/howitallworks/

### GitHub Repositories
- **Main Project**: https://github.com/amidaware/tacticalrmm
- **Community Linux Script**: https://github.com/netvolt/LinuxRMM-Script

### Scripts
- **Official Linux Installer**: https://raw.githubusercontent.com/amidaware/tacticalrmm/develop/api/tacticalrmm/core/agent_linux.sh
- **Community Linux Installer**: https://raw.githubusercontent.com/netvolt/LinuxRMM-Script/main/rmmagent-linux.sh

### Support
- **Email**: support@amidaware.com
- **Discord**: https://discord.gg/upGTkWp

---

## How to Use This Information

1. **For Understanding**: Start with QUICK_REFERENCE.md for quick overview
2. **For Details**: Read CODE_SIGNING_TOKENS_ANALYSIS.md for comprehensive details
3. **For Implementation**: Use IMPLEMENTATION_GUIDE.md as development blueprint
4. **For Questions**: Reference specific sections for clarification

---

## File Structure

```
/home/user/tactical-rmm/
├── README.md (original)
├── LICENSE (MIT)
├── SUMMARY.md (this file)
├── QUICK_REFERENCE.md ← Start here for quick info
├── CODE_SIGNING_TOKENS_ANALYSIS.md ← Complete technical details
└── IMPLEMENTATION_GUIDE.md ← Code examples and implementation blueprint
```

---

## Conclusion

Code signing tokens in Tactical RMM are a critical feature for enterprise deployments, enabling secure agent distribution with antivirus whitelisting capabilities. The system is well-designed with:

- Transparent operation (automatic token usage)
- Graceful fallback to unsigned agents
- Multi-platform support (Windows, Linux, macOS)
- Strong security model (sponsorship-based, token-per-instance)
- Clear error handling and troubleshooting paths

This feature branch should implement these tokens with proper security, testing, and documentation to enable sponsors to receive code-signed agents seamlessly.

